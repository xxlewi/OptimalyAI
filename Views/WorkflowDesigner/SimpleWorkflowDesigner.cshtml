@model OptimalyAI.ViewModels.WorkflowGraphViewModel
@{
    ViewData["Title"] = "Workflow Designer";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<style>
    .designer-container {
        display: flex;
        height: calc(100vh - 200px);
        gap: 20px;
    }
    
    .toolbox {
        width: 250px;
        background: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        overflow-y: auto;
    }
    
    .toolbox h6 {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
    }
    
    .tool-item {
        background: white;
        border: 2px solid #ddd;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        cursor: move;
        text-align: center;
        transition: all 0.2s;
    }
    
    .tool-item:hover {
        border-color: #007bff;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .canvas-container {
        flex: 1;
        background: white;
        border: 2px solid #ddd;
        border-radius: 8px;
        position: relative;
        overflow: auto;
    }
    
    #workflow-canvas {
        width: 2000px;
        height: 1500px;
        position: relative;
        background-image: 
            linear-gradient(rgba(0,0,0,.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0,0,0,.05) 1px, transparent 1px);
        background-size: 20px 20px;
    }
    
    .workflow-node {
        position: absolute;
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 15px;
        min-width: 180px;
        cursor: move;
        user-select: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .workflow-node.selected {
        border-color: #ff6b6b;
        box-shadow: 0 0 0 3px rgba(255,107,107,0.2);
    }
    
    .workflow-node.condition {
        width: 140px;
        height: 140px;
        border: none !important;
        background: transparent !important;
        padding: 0;
        min-width: unset;
        box-shadow: none !important;
    }
    
    .workflow-node.condition::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: rotate(45deg);
        border: 3px solid #ffc107;
        background: #fff8e1;
        border-radius: 15px;
        z-index: 1;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .workflow-node.condition .node-content-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 2;
    }
    
    .workflow-node.condition .node-header {
        margin-bottom: 5px;
        text-align: center;
        font-size: 14px;
        position: relative;
    }
    
    .workflow-node.condition .node-close {
        position: absolute;
        top: 23px;
        right: -40px;
        z-index: 3;
        background: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 1;
    }
    
    /* Position dots at diamond vertices */
    .workflow-node.condition .connection-dot.input {
        top: -27px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .workflow-node.condition .connection-dot.output {
        bottom: -8px;
        transform: translateX(-50%);
        top: auto;
    }
    
    .workflow-node.condition .connection-dot.output.true {
        left: 15%;
        bottom: 15%;
        background: #28a745;
        transform: translate(-50%, 50%);
    }
    
    .workflow-node.condition .connection-dot.output.false {
        right: 15%;
        bottom: 15%;
        left: auto;
        background: #dc3545;
        transform: translate(50%, 50%);
    }
    
    .workflow-node.parallel {
        width: 140px;
        height: 140px;
        border: none !important;
        background: transparent !important;
        padding: 0;
        min-width: unset;
        box-shadow: none !important;
    }
    
    .workflow-node.parallel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: rotate(45deg);
        border: 3px solid #6f42c1;
        background: #f3e5f5;
        border-radius: 15px;
        z-index: 1;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .workflow-node.parallel::after {
        content: '+';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        font-weight: bold;
        color: #6f42c1;
        z-index: 2;
    }
    
    .workflow-node.parallel .node-content-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 3;
    }
    
    .workflow-node.parallel .node-header {
        font-size: 14px;
        text-align: center;
        position: relative;
    }
    
    .workflow-node.parallel .node-close {
        position: absolute;
        top: 23px;
        right: -40px;
        z-index: 3;
        background: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 1;
    }
    
    /* Position parallel gateway dots on diamond vertices */
    .workflow-node.parallel .connection-dot.input {
        top: -27px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .workflow-node.parallel .connection-dot.output {
        bottom: -27px;
        left: 50%;
        background: #6f42c1;
        transform: translateX(-50%);
    }
    
    .node-header {
        font-weight: bold;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .node-close {
        cursor: pointer;
        color: #999;
        font-size: 18px;
        line-height: 1;
    }
    
    .node-close:hover {
        color: #dc3545;
    }
    
    .node-tools {
        font-size: 12px;
        margin-top: 8px;
    }
    
    .tool-badge {
        display: inline-block;
        background: #e3f2fd;
        color: #1976d2;
        padding: 2px 8px;
        border-radius: 4px;
        margin-right: 4px;
    }
    
    .connection-line {
        stroke: #007bff;
        stroke-width: 3;
        fill: none;
        pointer-events: none;
    }
    
    .connection-dot {
        width: 12px;
        height: 12px;
        background: #007bff;
        border: 2px solid white;
        border-radius: 50%;
        position: absolute;
        cursor: crosshair;
        z-index: 20;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .connection-dot:hover {
        background: #0056b3;
        transform: scale(1.2);
    }
    
    .connection-dot.input {
        left: 50%;
        top: -8px;
        transform: translateX(-50%);
    }
    
    .connection-dot.input:hover {
        transform: translateX(-50%) scale(1.2);
    }
    
    .connection-dot.output {
        left: 50%;
        bottom: -8px;
        transform: translateX(-50%);
    }
    
    .connection-dot.output:hover {
        transform: translateX(-50%) scale(1.2);
    }
    
    .toolbar {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    .zoom-controls {
        display: flex;
        gap: 5px;
        align-items: center;
        margin-left: auto;
    }
    
    .zoom-level {
        font-size: 14px;
        color: #666;
        min-width: 50px;
        text-align: center;
    }
    
    .badge-purple {
        background-color: #6f42c1;
        color: #fff;
    }
    
    .badge-purple:hover {
        background-color: #563d7c;
    }
</style>

<div class="content-header">
    <div class="container-fluid">
        <div class="row mb-2">
            <div class="col-sm-6">
                <h1>
                    <i class="fas fa-project-diagram"></i> Workflow Designer
                    <small class="text-muted">@Model.ProjectName</small>
                </h1>
            </div>
            <div class="col-sm-6">
                <div class="float-sm-right">
                    <a href="/Projects/@Model.ProjectId" class="btn btn-secondary">
                        <i class="fas fa-arrow-left"></i> Zpƒõt na projekt
                    </a>
                    <button class="btn btn-success" onclick="saveWorkflow()">
                        <i class="fas fa-save"></i> Ulo≈æit
                    </button>
                    <button class="btn btn-info" onclick="validateWorkflow()">
                        <i class="fas fa-check"></i> Validovat
                    </button>
                    <button class="btn btn-primary" onclick="testWorkflow()">
                        <i class="fas fa-play"></i> Test
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<section class="content">
    <div class="container-fluid">
        <div class="toolbar">
            <button class="btn btn-sm btn-secondary" onclick="clearWorkflow()">
                <i class="fas fa-trash"></i> Vyƒçistit
            </button>
            <button class="btn btn-sm btn-secondary" onclick="autoLayout()">
                <i class="fas fa-magic"></i> Automatick√© rozlo≈æen√≠
            </button>
            <div class="zoom-controls">
                <button class="btn btn-sm btn-outline-secondary" onclick="zoomOut()" title="Odd√°lit">
                    <i class="fas fa-search-minus"></i>
                </button>
                <span class="zoom-level">100%</span>
                <button class="btn btn-sm btn-outline-secondary" onclick="zoomIn()" title="P≈ôibl√≠≈æit">
                    <i class="fas fa-search-plus"></i>
                </button>
                <button class="btn btn-sm btn-outline-secondary" onclick="zoomReset()" title="Resetovat">
                    <i class="fas fa-compress"></i>
                </button>
            </div>
        </div>
        
        <div class="designer-container">
            <!-- Toolbox -->
            <div class="toolbox">
                <h5><i class="fas fa-toolbox"></i> N√°stroje</h5>
                
                <h6>Z√°kladn√≠ uzly</h6>
                <div class="tool-item" data-type="task" draggable="true">
                    <i class="fas fa-square"></i> Proces
                    <small style="display: block; font-size: 10px; color: #666;">Obd√©ln√≠k</small>
                </div>
                <div class="tool-item" data-type="condition" draggable="true">
                    <i class="fas fa-question-circle"></i> Rozhodnut√≠
                    <small style="display: block; font-size: 10px; color: #666;">Podm√≠nka</small>
                </div>
                <div class="tool-item" data-type="parallel" draggable="true">
                    <i class="fas fa-plus"></i> Paraleln√≠ br√°na
                    <small style="display: block; font-size: 10px; color: #666;">AND Gateway</small>
                </div>
                
                <hr>
                
                <h6>AI N√°stroje</h6>
                @foreach(var tool in ViewBag.AvailableTools ?? new List<string>())
                {
                    <div class="tool-item" data-type="ai-tool" data-tool="@tool" draggable="true">
                        <i class="fas fa-robot"></i> @tool.Replace("_", " ")
                    </div>
                }
            </div>
            
            <!-- Canvas -->
            <div class="canvas-container">
                <div id="workflow-canvas">
                    <svg id="connections-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; z-index: 100;">
                        <defs>
                            <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#007bff" />
                            </marker>
                            <marker id="arrowhead-green" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#28a745" />
                            </marker>
                            <marker id="arrowhead-red" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#dc3545" />
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- I/O Configuration Modal -->
<div class="modal fade" id="ioConfigModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Konfigurace vstup≈Ø a v√Ωstup≈Ø workflow</h5>
                <button type="button" class="close" data-dismiss="modal">
                    <span>&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <!-- Input Configuration -->
                <h6><i class="fas fa-sign-in-alt"></i> Konfigurace vstupu</h6>
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="form-group">
                            <label>Typ vstupu</label>
                            <select class="form-control" id="modalInputType" onchange="updateInputConfig()">
                                <option value="files">üìÅ Soubory</option>
                                <option value="images">üñºÔ∏è Obr√°zky</option>
                                <option value="api">üåê API</option>
                                <option value="database">üóÑÔ∏è Datab√°ze</option>
                                <option value="csv">üìä CSV</option>
                                <option value="manual">‚úèÔ∏è Manu√°ln√≠</option>
                            </select>
                        </div>
                        
                        <div id="inputConfigDetails">
                            <!-- Dynamic content based on input type -->
                        </div>
                    </div>
                </div>
                
                <!-- Output Configuration -->
                <h6><i class="fas fa-sign-out-alt"></i> Konfigurace v√Ωstupu</h6>
                <div class="card">
                    <div class="card-body">
                        <div class="form-group">
                            <label>Typ v√Ωstupu</label>
                            <select class="form-control" id="modalOutputType" onchange="updateOutputConfig()">
                                <option value="excel">üìä Excel</option>
                                <option value="json">üìÑ JSON</option>
                                <option value="csv">üìä CSV</option>
                                <option value="api">üì§ API</option>
                                <option value="database">üíø Datab√°ze</option>
                                <option value="email">üìß Email</option>
                            </select>
                        </div>
                        
                        <div id="outputConfigDetails">
                            <!-- Dynamic content based on output type -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Zru≈°it</button>
                <button type="button" class="btn btn-primary" onclick="saveIOConfig()">
                    <i class="fas fa-save"></i> Ulo≈æit konfiguraci
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Node Edit Modal -->
<div class="modal fade" id="nodeEditModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Upravit uzel</h5>
                <button type="button" class="close" data-dismiss="modal">
                    <span>&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editingNodeId">
                <div class="form-group">
                    <label>N√°zev</label>
                    <input type="text" class="form-control" id="nodeName">
                </div>
                <div class="form-group">
                    <label>Popis</label>
                    <textarea class="form-control" id="nodeDescription" rows="3"></textarea>
                </div>
                <div class="form-group" id="toolsSection">
                    <label>AI N√°stroje</label>
                    <select multiple class="form-control" id="nodeTools" size="5">
                        @foreach(var tool in ViewBag.AvailableTools ?? new List<string>())
                        {
                            <option value="@tool">@tool.Replace("_", " ")</option>
                        }
                    </select>
                    <small class="text-muted">Dr≈æte Ctrl pro v√Ωbƒõr v√≠ce n√°stroj≈Ø</small>
                </div>
                <div class="form-group" id="orchestratorSection">
                    <div class="custom-control custom-switch mb-3">
                        <input type="checkbox" class="custom-control-input" id="nodeUseReAct">
                        <label class="custom-control-label" for="nodeUseReAct">
                            <i class="fas fa-brain"></i> Pou≈æ√≠t ReAct pattern
                        </label>
                    </div>
                    <label>Orchestr√°tor (voliteln√©)</label>
                    <select class="form-control" id="nodeOrchestrator">
                        <option value="">-- Pou≈æ√≠t v√Ωchoz√≠ --</option>
                        @foreach(var orchestrator in ViewBag.Orchestrators ?? new List<string>())
                        {
                            <option value="@orchestrator">@orchestrator</option>
                        }
                    </select>
                    <small class="text-muted">P≈ôep√≠≈°e v√Ωchoz√≠ orchestr√°tor pro tento uzel</small>
                </div>
                <div class="form-group" id="advancedSection" style="display: none;">
                    <button type="button" class="btn btn-sm btn-link" onclick="toggleAdvancedSettings()">
                        <i class="fas fa-cog"></i> Pokroƒçil√° nastaven√≠
                    </button>
                    <div id="advancedSettingsContent" style="display: none;">
                        <div class="form-group">
                            <label>Model (voliteln√©)</label>
                            <input type="text" class="form-control" id="nodeModel" placeholder="nap≈ô. llama3.1:70b">
                        </div>
                        <div class="form-group">
                            <label>Temperature (voliteln√©)</label>
                            <input type="number" class="form-control" id="nodeTemperature" min="0" max="2" step="0.1" placeholder="0.7">
                        </div>
                        <div class="form-group">
                            <label>System Prompt (voliteln√©)</label>
                            <textarea class="form-control" id="nodeSystemPrompt" rows="2" placeholder="Specifick√Ω prompt pro tento uzel"></textarea>
                        </div>
                    </div>
                </div>
                <div class="form-group" id="conditionSection" style="display: none;">
                    <label>Podm√≠nka</label>
                    <input type="text" class="form-control" id="nodeCondition" placeholder="result > 0">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger" onclick="deleteCurrentNode()">
                    <i class="fas fa-trash"></i> Smazat
                </button>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Zru≈°it</button>
                <button type="button" class="btn btn-primary" onclick="updateCurrentNode()">
                    <i class="fas fa-save"></i> Ulo≈æit
                </button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
<script>
    // Workflow state
    let nodes = {};
    let connections = [];
    let selectedNode = null;
    let nodeIdCounter = 1;
    let draggedElement = null;
    let isConnecting = false;
    let connectionStart = null;
    const currentProjectId = '@Model.ProjectId';
    let currentZoom = 1.0;
    
    // Initialize
    $(document).ready(function() {
        initializeDragAndDrop();
        initializeCanvas();
        initializeKeyboardShortcuts();
        
        // Start with 100% zoom
        currentZoom = 1.0;
        applyZoom();
        
        // Try to load saved workflow, or create default
        loadWorkflowFromServer();
    });
    
    // Initialize drag and drop
    function initializeDragAndDrop() {
        // Toolbox items
        $('.tool-item').on('dragstart', function(e) {
            e.originalEvent.dataTransfer.setData('type', $(this).data('type'));
            e.originalEvent.dataTransfer.setData('tool', $(this).data('tool') || '');
        });
        
        // Canvas
        $('#workflow-canvas').on('dragover', function(e) {
            e.preventDefault();
        }).on('drop', function(e) {
            e.preventDefault();
            const type = e.originalEvent.dataTransfer.getData('type');
            const tool = e.originalEvent.dataTransfer.getData('tool');
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            createNode(type, x, y, tool);
        });
    }
    
    // Initialize canvas events
    function initializeCanvas() {
        $('#workflow-canvas').on('click', function(e) {
            if (e.target === this) {
                deselectAll();
            }
        });
    }
    
    // Initialize keyboard shortcuts
    function initializeKeyboardShortcuts() {
        $(document).on('keydown', function(e) {
            // Delete or Backspace key
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Prevent backspace from navigating back if not in an input field
                if (!$(e.target).is('input, textarea')) {
                    e.preventDefault();
                    
                    // Delete selected node if any
                    if (selectedNode) {
                        removeNode(selectedNode);
                    }
                }
            }
        });
    }
    
    // Create new node
    function createNode(type, x, y, tool) {
        const nodeId = 'node_' + nodeIdCounter++;
        
        // Default descriptions
        const defaultDescriptions = {
            'task': 'Zpracov√°n√≠ dat nebo operace',
            'condition': 'Rozhodovac√≠ bod (if/else)',
            'parallel': 'Paraleln√≠ zpracov√°n√≠',
            'ai-tool': 'Vol√°n√≠ AI n√°stroje'
        };
        
        // If no position provided, auto-position
        if (!x || !y) {
            const nodeCount = Object.keys(nodes).length;
            x = 1000;  // Center horizontally
            y = 100 + (nodeCount * 120);  // Stack vertically
        }
        
        // Adjust position to center the node at click/drop point
        let adjustedX = x;
        let adjustedY = y;
        
        // Offset based on node type to center at cursor
        if (type === 'condition' || type === 'parallel') {
            adjustedX = x - 70; // Half of diamond width
            adjustedY = y - 70; // Half of diamond height  
        } else {
            adjustedX = x - 90; // Half of normal node width
            adjustedY = y - 30; // Approximate half height
        }
        
        const node = {
            id: nodeId,
            type: type,
            name: tool ? tool.replace(/_/g, ' ') : getNodeTypeName(type),
            x: adjustedX,
            y: adjustedY,
            tools: tool ? [tool] : [],
            description: defaultDescriptions[type] || ''
        };
        
        nodes[nodeId] = node;
        renderNode(node);
    }
    
    // Get node type display name
    function getNodeTypeName(type) {
        const names = {
            'task': 'Proces',
            'condition': 'Rozhodnut√≠',
            'parallel': 'Paraleln√≠ br√°na',
            'ai-tool': 'AI N√°stroj'
        };
        return names[type] || type;
    }
    
    // Render node
    function renderNode(node) {
        const nodeEl = $('<div>')
            .addClass('workflow-node')
            .addClass(node.type)
            .attr('id', node.id)
            .css({
                left: node.x + 'px',
                top: node.y + 'px'
            });
        
        // Create wrapper for diamond-shaped nodes (condition and parallel)
        let contentWrapper;
        if (node.type === 'condition' || node.type === 'parallel') {
            contentWrapper = $('<div>').addClass('node-content-wrapper');
            nodeEl.append(contentWrapper);
        } else {
            contentWrapper = nodeEl;
        }
        
        // Header
        const header = $('<div>').addClass('node-header');
        header.append($('<span>').html(`<i class="${getNodeIcon(node.type)}"></i> ${node.name}`));
        
        // Close button for all nodes
        header.append($('<span>').addClass('node-close').html('√ó').click(function(e) {
            e.stopPropagation();
            removeNode(node.id);
        }));
        
        contentWrapper.append(header);
        
        // Description
        if (node.description) {
            const descDiv = $('<div>')
                .css({
                    fontSize: '12px',
                    color: '#666',
                    marginTop: '5px',
                    fontStyle: 'italic'
                })
                .text(node.description);
            contentWrapper.append(descDiv);
        }
        
        // Tools
        if (node.tools && node.tools.length > 0) {
            const toolsDiv = $('<div>').addClass('node-tools');
            node.tools.forEach(tool => {
                toolsDiv.append($('<span>').addClass('tool-badge').text(tool.replace(/_/g, ' ')));
            });
            contentWrapper.append(toolsDiv);
        }
        
        // ReAct badge
        if (node.useReAct) {
            const reactBadge = $('<span>')
                .addClass('badge badge-purple')
                .html('<i class="fas fa-brain"></i> ReAct')
                .css({
                    position: 'absolute',
                    top: '5px',
                    right: '25px',
                    fontSize: '11px'
                });
            nodeEl.append(reactBadge);
        }
        
        // Connection dots - all nodes can have input and output
        nodeEl.append($('<div>').addClass('connection-dot input'));
        
        if (node.type === 'condition') {
                // Two outputs for condition - TRUE and FALSE
                nodeEl.append($('<div>')
                    .addClass('connection-dot output true')
                    .attr('title', 'TRUE')
                    .attr('data-branch', 'true'));
                nodeEl.append($('<div>')
                    .addClass('connection-dot output false')
                    .attr('title', 'FALSE')
                    .attr('data-branch', 'false'));
        } else {
            nodeEl.append($('<div>').addClass('connection-dot output'));
        }
        
        // Events
        nodeEl.on('click', function(e) {
            e.stopPropagation();
            selectNode(node.id);
        });
        
        nodeEl.on('dblclick', function(e) {
            e.stopPropagation();
            editNode(node.id);
        });
        
        // Make draggable
        makeDraggable(nodeEl, node);
        
        // Connection events - mus√≠me pou≈æ√≠t delegated events
        nodeEl.on('mousedown', '.connection-dot.output', function(e) {
            e.stopPropagation();
            e.preventDefault();
            const branch = $(this).attr('data-branch');
            startConnection(node.id, branch);
            return false;
        });
        
        nodeEl.on('mouseup', '.connection-dot.input', function(e) {
            e.stopPropagation();
            e.preventDefault();
            if (isConnecting && connectionStart && connectionStart.nodeId !== node.id) {
                endConnection(node.id);
            }
            return false;
        });
        
        $('#workflow-canvas').append(nodeEl);
    }
    
    // Get node icon
    function getNodeIcon(type) {
        const icons = {
            'task': 'fas fa-tasks',
            'condition': 'fas fa-question-circle',
            'parallel': 'fas fa-code-branch',
            'ai-tool': 'fas fa-robot'
        };
        return icons[type] || 'fas fa-circle';
    }
    
    // Make element draggable
    function makeDraggable(element, node) {
        let isDragging = false;
        let startX, startY, initialX, initialY;
        
        element.on('mousedown', function(e) {
            if ($(e.target).hasClass('node-close') || $(e.target).hasClass('connection-dot')) return;
            
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            initialX = node.x;
            initialY = node.y;
            
            $(document).on('mousemove.drag', function(e) {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                node.x = initialX + dx;
                node.y = initialY + dy;
                
                element.css({
                    left: node.x + 'px',
                    top: node.y + 'px'
                });
                
                updateConnections();
            });
            
            $(document).on('mouseup.drag', function() {
                isDragging = false;
                $(document).off('.drag');
            });
        });
    }
    
    // Connection management
    function startConnection(nodeId, branch) {
        console.log('Starting connection from:', nodeId, 'branch:', branch);
        isConnecting = true;
        connectionStart = {
            nodeId: nodeId,
            branch: branch
        };
        
        // Change cursor
        $('#workflow-canvas').css('cursor', 'crosshair');
        
        // Create temporary line
        const tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tempLine.setAttribute('id', 'temp-connection');
        tempLine.setAttribute('class', 'connection-line');
        tempLine.setAttribute('stroke', '#ff6b6b');
        tempLine.setAttribute('stroke-dasharray', '5,5');
        $('#connections-svg')[0].appendChild(tempLine);
        
        // Get start position - from output dot
        const startNode = nodes[nodeId];
        const startEl = $('#' + nodeId);
        
        // Find the specific output dot we're dragging from
        let outputDot;
        if (branch) {
            outputDot = startEl.find(`.connection-dot.output.${branch}`);
        } else {
            outputDot = startEl.find('.connection-dot.output');
        }
        
        // Use getBoundingClientRect for accurate position
        const canvasRect = $('#workflow-canvas')[0].getBoundingClientRect();
        const outputDotRect = outputDot[0].getBoundingClientRect();
        const startX = outputDotRect.left - canvasRect.left + (outputDotRect.width / 2);
        const startY = outputDotRect.top - canvasRect.top + (outputDotRect.height / 2);
        
        // Mouse move to update temp line
        $(document).on('mousemove.connection', function(e) {
            const rect = $('#workflow-canvas')[0].getBoundingClientRect();
            const x = e.clientX - rect.left + $('#workflow-canvas').scrollLeft();
            const y = e.clientY - rect.top + $('#workflow-canvas').scrollTop();
            
            tempLine.setAttribute('x1', startX);
            tempLine.setAttribute('y1', startY);
            tempLine.setAttribute('x2', x);
            tempLine.setAttribute('y2', y);
        });
        
        // Global mouseup to cancel connection
        $(document).on('mouseup.connection', function(e) {
            // If not on a valid input dot, cancel
            if (!($(e.target).hasClass('connection-dot') && $(e.target).hasClass('input'))) {
                console.log('Connection cancelled');
                
                // Clean up
                $('#temp-connection').remove();
                isConnecting = false;
                connectionStart = null;
                $('#workflow-canvas').css('cursor', 'default');
                $(document).off('.connection');
            }
        });
    }
    
    function endConnection(nodeId) {
        console.log('Ending connection at:', nodeId);
        if (connectionStart && connectionStart.nodeId !== nodeId) {
            // Check if connection already exists
            const exists = connections.some(c => 
                c.from === connectionStart.nodeId && c.to === nodeId
            );
            
            if (!exists) {
                // Check if target already has an input connection - but allow it for now
                const existingToInput = connections.filter(c => c.to === nodeId);
                if (existingToInput.length > 0) {
                    console.log('Warning: Node already has input connection, but allowing new one');
                    // Remove the old connection to this node
                    connections = connections.filter(c => c.to !== nodeId);
                }
                
                // Check if output already has a connection (except for parallel gateway)
                const fromNode = nodes[connectionStart.nodeId];
                const existingFromOutput = connections.filter(c => 
                    c.from === connectionStart.nodeId && 
                    (!connectionStart.branch || c.branch === connectionStart.branch)
                );
                
                // Allow only one connection per output, except for parallel gateway
                if (existingFromOutput.length > 0 && fromNode.type !== 'parallel') {
                    toastr.warning('Tento v√Ωstup u≈æ m√° spojen√≠. Nejd≈ô√≠v ho odstra≈àte.');
                    cancelConnection();
                    return;
                }
                
                const connection = {
                    from: connectionStart.nodeId,
                    to: nodeId
                };
                
                // If from a condition node, store which branch
                if (connectionStart.branch) {
                    connection.branch = connectionStart.branch;
                }
                
                connections.push(connection);
                updateConnections();
                
                const branchInfo = connectionStart.branch ? ` (${connectionStart.branch.toUpperCase()})` : '';
                toastr.success('Propojeno' + branchInfo + '!');
            } else {
                toastr.warning('Toto propojen√≠ ji≈æ existuje');
            }
        }
        
        // Clean up
        $('#temp-connection').remove();
        isConnecting = false;
        connectionStart = null;
        $('#workflow-canvas').css('cursor', 'default');
        $(document).off('.connection');
    }
    
    function cancelConnection() {
        // Clean up
        $('#temp-connection').remove();
        isConnecting = false;
        connectionStart = null;
        $('#workflow-canvas').css('cursor', 'default');
        $(document).off('.connection');
    }
    
    // Update SVG connections
    function updateConnections() {
        const svg = $('#connections-svg');
        svg.find('line:not(#temp-connection)').remove();
        
        connections.forEach(conn => {
            const fromNode = nodes[conn.from];
            const toNode = nodes[conn.to];
            
            if (fromNode && toNode) {
                const fromEl = $('#' + conn.from);
                const toEl = $('#' + conn.to);
                
                // Get exact positions from connection dots
                let outputDot;
                if (conn.branch && fromNode.type === 'condition') {
                    outputDot = fromEl.find(`.connection-dot.output.${conn.branch}`);
                } else {
                    outputDot = fromEl.find('.connection-dot.output');
                }
                
                const inputDot = toEl.find('.connection-dot.input');
                
                // Use getBoundingClientRect for accurate positions including transforms
                const canvasRect = $('#workflow-canvas')[0].getBoundingClientRect();
                const outputDotRect = outputDot[0].getBoundingClientRect();
                const inputDotRect = inputDot[0].getBoundingClientRect();
                
                // Calculate positions relative to canvas
                const x1 = outputDotRect.left - canvasRect.left + (outputDotRect.width / 2);
                const y1 = outputDotRect.top - canvasRect.top + (outputDotRect.height / 2);
                const x2 = inputDotRect.left - canvasRect.left + (inputDotRect.width / 2);
                const y2 = inputDotRect.top - canvasRect.top + (inputDotRect.height / 2);
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('class', 'connection-line');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                
                // Color code branches and use appropriate arrowhead
                if (conn.branch === 'true') {
                    line.setAttribute('stroke', '#28a745');
                    line.setAttribute('marker-end', 'url(#arrowhead-green)');
                } else if (conn.branch === 'false') {
                    line.setAttribute('stroke', '#dc3545');
                    line.setAttribute('marker-end', 'url(#arrowhead-red)');
                }
                
                svg[0].appendChild(line);
            }
        });
    }
    
    // Node selection
    function selectNode(nodeId) {
        deselectAll();
        selectedNode = nodeId;
        $('#' + nodeId).addClass('selected');
    }
    
    function deselectAll() {
        selectedNode = null;
        $('.workflow-node').removeClass('selected');
    }
    
    // Edit node
    function editNode(nodeId) {
        const node = nodes[nodeId];
        if (!node) return;
        
        $('#editingNodeId').val(nodeId);
        $('#nodeName').val(node.name);
        $('#nodeDescription').val(node.description || '');
        
        // Show/hide sections based on type
        if (node.type === 'condition' || node.type === 'parallel') {
            $('#toolsSection').hide();
            $('#orchestratorSection').hide();
            $('#advancedSection').hide();
            $('#conditionSection').toggle(node.type === 'condition');
            if (node.type === 'condition') {
                $('#nodeCondition').val(node.condition || '');
            }
        } else {
            $('#toolsSection').show();
            $('#orchestratorSection').show();
            $('#advancedSection').show();
            $('#conditionSection').hide();
            
            // Set selected tools
            $('#nodeTools').val(node.tools || []);
            
            // Set orchestrator settings
            $('#nodeUseReAct').prop('checked', node.useReAct || false);
            $('#nodeOrchestrator').val(node.orchestrator || '');
            $('#nodeModel').val(node.model || '');
            $('#nodeTemperature').val(node.temperature || '');
            $('#nodeSystemPrompt').val(node.systemPrompt || '');
        }
        
        // Reset advanced settings visibility
        $('#advancedSettingsContent').hide();
        
        $('#nodeEditModal').modal('show');
    }
    
    // Update node
    function updateCurrentNode() {
        const nodeId = $('#editingNodeId').val();
        const node = nodes[nodeId];
        if (!node) return;
        
        node.name = $('#nodeName').val();
        node.description = $('#nodeDescription').val();
        
        if (node.type === 'condition') {
            node.condition = $('#nodeCondition').val();
        } else {
            node.tools = $('#nodeTools').val() || [];
            
            // Save orchestrator settings
            node.useReAct = $('#nodeUseReAct').is(':checked');
            node.orchestrator = $('#nodeOrchestrator').val() || null;
            node.model = $('#nodeModel').val() || null;
            node.temperature = $('#nodeTemperature').val() ? parseFloat($('#nodeTemperature').val()) : null;
            node.systemPrompt = $('#nodeSystemPrompt').val() || null;
        }
        
        // Re-render node
        $('#' + nodeId).remove();
        renderNode(node);
        
        $('#nodeEditModal').modal('hide');
    }
    
    // Delete node
    function deleteCurrentNode() {
        const nodeId = $('#editingNodeId').val();
        removeNode(nodeId);
        $('#nodeEditModal').modal('hide');
    }
    
    function removeNode(nodeId) {
        delete nodes[nodeId];
        $('#' + nodeId).remove();
        
        // Remove connections
        connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
        updateConnections();
    }
    
    // Load initial workflow
    function loadInitialWorkflow() {
        // Simple fixed positions - no complex calculations
        const canvasCenterX = 1000;  // Center of 2000px wide canvas
        
        // Don't create any default nodes - let user build workflow from scratch
        // Just scroll to center the canvas
        setTimeout(() => {
            const container = $('.canvas-container');
            const containerWidth = container.width();
            
            // Center horizontally
            const scrollLeft = canvasCenterX - (containerWidth / 2);
            container.scrollLeft(scrollLeft);
            container.scrollTop(0);
        }, 100);
        
        // Load existing workflow if saved
        const model = @Html.Raw(Json.Serialize(Model));
        if (model && model.metadata && model.metadata.orchestratorData) {
            loadFromOrchestratorFormat(model.metadata.orchestratorData);
        }
    }
    
    // Workflow operations
    function saveWorkflow() {
        // Convert to orchestrator-compatible format
        const workflowData = convertToOrchestratorFormat();
        
        console.log('Saving workflow:', workflowData);
        
        // Send to server
        $.ajax({
            url: '/WorkflowDesigner/SaveWorkflow',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                ProjectId: '@Model.ProjectId',
                WorkflowData: workflowData
            }),
            success: function(response) {
                if (response.success) {
                    toastr.success('Workflow ulo≈æeno');
                } else {
                    toastr.error('Chyba p≈ôi ukl√°d√°n√≠');
                }
            },
            error: function() {
                toastr.error('Chyba p≈ôi komunikaci se serverem');
            }
        });
    }
    
    // I/O Configuration
    let workflowIOConfig = {
        input: {
            type: 'images',
            config: {
                formats: ['jpg', 'png', 'webp'],
                maxSize: '10MB',
                source: 'upload'
            }
        },
        output: {
            type: 'excel',
            config: {
                format: 'xlsx',
                includeImages: true,
                fields: ['url', 'price', 'availability', 'similarity']
            }
        }
    };
    
    // Show I/O configuration modal
    function showIOConfig() {
        $('#modalInputType').val(workflowIOConfig.input.type);
        $('#modalOutputType').val(workflowIOConfig.output.type);
        updateInputConfig();
        updateOutputConfig();
        $('#ioConfigModal').modal('show');
    }
    
    // Update input configuration UI
    function updateInputConfig() {
        const inputType = $('#modalInputType').val();
        let configHtml = '';
        
        switch(inputType) {
            case 'images':
                configHtml = `
                    <div class="form-group">
                        <label>Podporovan√© form√°ty</label>
                        <input type="text" class="form-control" id="imageFormats" value="jpg, png, webp" placeholder="jpg, png, gif">
                    </div>
                    <div class="form-group">
                        <label>Max. velikost souboru</label>
                        <input type="text" class="form-control" id="maxFileSize" value="10MB">
                    </div>
                    <div class="form-group">
                        <label>Zdroj</label>
                        <select class="form-control" id="imageSource">
                            <option value="upload">Upload soubor≈Ø</option>
                            <option value="url">URL adresa</option>
                            <option value="api">API endpoint</option>
                        </select>
                    </div>
                `;
                break;
                
            case 'api':
                configHtml = `
                    <div class="form-group">
                        <label>Endpoint URL</label>
                        <input type="url" class="form-control" id="apiEndpoint" placeholder="https://api.example.com/data">
                    </div>
                    <div class="form-group">
                        <label>Metoda</label>
                        <select class="form-control" id="apiMethod">
                            <option value="GET">GET</option>
                            <option value="POST">POST</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Autentizace</label>
                        <select class="form-control" id="apiAuth">
                            <option value="none">≈Ω√°dn√°</option>
                            <option value="bearer">Bearer Token</option>
                            <option value="apikey">API Key</option>
                        </select>
                    </div>
                `;
                break;
                
            case 'database':
                configHtml = `
                    <div class="form-group">
                        <label>Typ datab√°ze</label>
                        <select class="form-control" id="dbType">
                            <option value="postgresql">PostgreSQL</option>
                            <option value="mysql">MySQL</option>
                            <option value="mongodb">MongoDB</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Tabulka/Kolekce</label>
                        <input type="text" class="form-control" id="dbTable" placeholder="products">
                    </div>
                    <div class="form-group">
                        <label>Filtr (SQL WHERE / MongoDB query)</label>
                        <textarea class="form-control" id="dbFilter" rows="2"></textarea>
                    </div>
                `;
                break;
                
            case 'csv':
                configHtml = `
                    <div class="form-group">
                        <label>Oddƒõlovaƒç</label>
                        <select class="form-control" id="csvDelimiter">
                            <option value=",">ƒå√°rka (,)</option>
                            <option value=";">St≈ôedn√≠k (;)</option>
                            <option value="\\t">Tabul√°tor</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>K√≥dov√°n√≠</label>
                        <select class="form-control" id="csvEncoding">
                            <option value="utf-8">UTF-8</option>
                            <option value="windows-1250">Windows-1250</option>
                        </select>
                    </div>
                    <div class="custom-control custom-checkbox">
                        <input type="checkbox" class="custom-control-input" id="csvHeaders" checked>
                        <label class="custom-control-label" for="csvHeaders">Prvn√≠ ≈ô√°dek obsahuje hlaviƒçky</label>
                    </div>
                `;
                break;
        }
        
        $('#inputConfigDetails').html(configHtml);
    }
    
    // Update output configuration UI
    function updateOutputConfig() {
        const outputType = $('#modalOutputType').val();
        let configHtml = '';
        
        switch(outputType) {
            case 'excel':
                configHtml = `
                    <div class="form-group">
                        <label>N√°zev souboru</label>
                        <input type="text" class="form-control" id="excelFilename" value="vysledky_{timestamp}.xlsx">
                    </div>
                    <div class="form-group">
                        <label>Sloupce</label>
                        <textarea class="form-control" id="excelColumns" rows="3">URL produktu
Cena
Dostupnost
Sk√≥re podobnosti
Obr√°zek</textarea>
                    </div>
                    <div class="custom-control custom-checkbox">
                        <input type="checkbox" class="custom-control-input" id="excelIncludeImages" checked>
                        <label class="custom-control-label" for="excelIncludeImages">Vlo≈æit obr√°zky p≈ô√≠mo do Excelu</label>
                    </div>
                `;
                break;
                
            case 'api':
                configHtml = `
                    <div class="form-group">
                        <label>Webhook URL</label>
                        <input type="url" class="form-control" id="webhookUrl" placeholder="https://webhook.example.com/results">
                    </div>
                    <div class="form-group">
                        <label>Metoda</label>
                        <select class="form-control" id="webhookMethod">
                            <option value="POST">POST</option>
                            <option value="PUT">PUT</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Headers</label>
                        <textarea class="form-control" id="webhookHeaders" rows="2" placeholder='{"Authorization": "Bearer token"}'></textarea>
                    </div>
                `;
                break;
                
            case 'email':
                configHtml = `
                    <div class="form-group">
                        <label>P≈ô√≠jemci (oddƒõlen√© ƒç√°rkou)</label>
                        <input type="text" class="form-control" id="emailRecipients" placeholder="user@example.com, admin@example.com">
                    </div>
                    <div class="form-group">
                        <label>P≈ôedmƒõt</label>
                        <input type="text" class="form-control" id="emailSubject" value="V√Ωsledky workflow {workflow_name}">
                    </div>
                    <div class="form-group">
                        <label>Form√°t p≈ô√≠lohy</label>
                        <select class="form-control" id="emailAttachmentFormat">
                            <option value="excel">Excel</option>
                            <option value="csv">CSV</option>
                            <option value="pdf">PDF</option>
                        </select>
                    </div>
                `;
                break;
        }
        
        $('#outputConfigDetails').html(configHtml);
    }
    
    // Save I/O configuration
    function saveIOConfig() {
        const inputType = $('#modalInputType').val();
        const outputType = $('#modalOutputType').val();
        
        // Save input config
        workflowIOConfig.input.type = inputType;
        workflowIOConfig.input.config = {};
        
        // Save output config
        workflowIOConfig.output.type = outputType;
        workflowIOConfig.output.config = {};
        
        // Update the dropdowns in toolbox
        $('#workflowInputType').val(inputType);
        $('#workflowOutputType').val(outputType);
        
        $('#ioConfigModal').modal('hide');
        toastr.success('Konfigurace vstup≈Ø a v√Ωstup≈Ø ulo≈æena');
    }
    
    // Convert visual workflow to orchestrator format
    function convertToOrchestratorFormat() {
        console.log('Converting workflow with connections:', connections);
        const steps = [];
        const nodeMap = {};
        
        // First pass - create steps
        Object.values(nodes).forEach((node, index) => {
            const step = {
                id: node.id,
                name: node.name,
                type: mapNodeTypeToStepType(node.type),
                description: node.description || '',
                position: index
            };
            
            // Add type-specific properties
            if (node.type === 'task' || node.type === 'ai-tool') {
                step.tools = node.tools || [];
                step.useReAct = node.useReAct || false;
                // Add orchestrator-specific properties
                step.orchestrator = node.orchestrator || null;
                step.systemPrompt = node.systemPrompt || null;
                step.model = node.model || null;
                step.temperature = node.temperature || null;
            } else if (node.type === 'condition') {
                step.condition = node.condition || 'true';
                step.branches = {
                    true: [],
                    false: []
                };
            } else if (node.type === 'parallel') {
                step.branches = [];
            }
            
            steps.push(step);
            nodeMap[node.id] = step;
        });
        
        // Second pass - build connections
        // Find nodes without incoming connections (entry points)
        const nodesWithIncoming = new Set(connections.map(c => c.to));
        const entryNodes = Object.keys(nodeMap).filter(id => !nodesWithIncoming.has(id));
        const firstStepId = entryNodes[0] || Object.keys(nodeMap)[0];
        
        // Find nodes without outgoing connections (exit points)
        const nodesWithOutgoing = new Set(connections.map(c => c.from));
        const lastStepIds = Object.keys(nodeMap).filter(id => !nodesWithOutgoing.has(id));
        
        // Build step sequence
        steps.forEach(step => {
            const outgoingConnections = connections.filter(c => c.from === step.id);
            console.log(`Processing ${step.id} (${step.type}), outgoing connections:`, outgoingConnections);
            
            if (step.type === 'decision') {
                // For conditions, use the branch info from connection
                outgoingConnections.forEach(conn => {
                    const targetStep = nodeMap[conn.to];
                    if (targetStep) {
                        const branch = conn.branch || 'true';
                        step.branches[branch].push(targetStep.id);
                    }
                });
                // Remove 'next' if it was set
                delete step.next;
            } else if (step.type === 'parallel-gateway') {
                // For parallel, all connections are branches
                step.branches = outgoingConnections
                    .map(conn => nodeMap[conn.to]?.id)
                    .filter(id => id != null);
                // Remove 'next' if it was set
                delete step.next;
            } else {
                // For regular steps, find next step
                const nextConnection = outgoingConnections[0];
                if (nextConnection) {
                    const nextStep = nodeMap[nextConnection.to];
                    if (nextStep) {
                        step.next = nextStep.id;
                    }
                } else {
                    // No outgoing connection - this is a final step
                    step.isFinal = true;
                }
            }
        });
        
        // Get the current orchestrator settings if available
        const model = @Html.Raw(Json.Serialize(Model));
        const currentSettings = model?.metadata?.settings || {};
        
        return {
            name: 'Workflow ' + new Date().toISOString(),
            description: 'Visual workflow designer output',
            firstStepId: firstStepId,
            lastStepIds: lastStepIds,
            steps: steps,
            input: workflowIOConfig.input,  // Add input configuration
            output: workflowIOConfig.output, // Add output configuration
            metadata: {
                createdWith: 'SimpleWorkflowDesigner',
                createdAt: new Date().toISOString(),
                nodePositions: Object.values(nodes).reduce((acc, node) => {
                    acc[node.id] = { 
                        x: node.x, 
                        y: node.y,
                        type: node.type
                    };
                    return acc;
                }, {}),
                settings: currentSettings // Preserve orchestrator settings
            }
        };
    }
    
    function mapNodeTypeToStepType(nodeType) {
        const typeMap = {
            'task': 'process',
            'ai-tool': 'ai-tool',
            'condition': 'decision',
            'parallel': 'parallel-gateway'
        };
        return typeMap[nodeType] || nodeType;
    }
    
    function validateWorkflow() {
        const errors = [];
        
        // Check if there are any nodes
        if (Object.keys(nodes).length === 0) {
            errors.push('Workflow je pr√°zdn√©');
        }
        
        // Check disconnected nodes (but first/last nodes can have open connections)
        Object.values(nodes).forEach(node => {
            const hasInput = connections.some(c => c.to === node.id);
            const hasOutput = connections.some(c => c.from === node.id);
            
            // At least one node should be an entry point (no input)
            // At least one node should be an exit point (no output)
            // But not all nodes need both
            if (!hasInput && !hasOutput && Object.keys(nodes).length > 1) {
                errors.push(`Uzel "${node.name}" nen√≠ propojen√Ω`);
            }
        });
        
        if (errors.length === 0) {
            toastr.success('Workflow je validn√≠');
        } else {
            toastr.error(errors.join('<br>'), 'Chyby ve workflow');
        }
    }
    
    function testWorkflow() {
        const workflowData = convertToOrchestratorFormat();
        
        // Show JSON in console for debugging
        console.log('Orchestrator format:', JSON.stringify(workflowData, null, 2));
        
        // You can also show it in a modal or download as file
        const jsonStr = JSON.stringify(workflowData, null, 2);
        
        // Create download link
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `workflow-${currentProjectId || 'export'}-orchestrator.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        toastr.info('Export pro orchestr√°tor byl sta≈æen');
    }
    
    function clearWorkflow() {
        if (confirm('Opravdu vymazat workflow?')) {
            nodes = {};
            connections = [];
            $('.workflow-node').remove();
            $('svg line').remove();
            
            // Canvas is now empty - ready for new workflow
        }
    }
    
    function autoLayout() {
        // Check if there are any nodes
        if (Object.keys(nodes).length === 0) {
            toastr.warning('Nejsou ≈æ√°dn√© uzly k rozlo≈æen√≠');
            return;
        }
        
        // Find entry point - node without incoming connections
        const nodesWithIncoming = new Set(connections.map(c => c.to));
        let startNodeId = Object.keys(nodes).find(id => !nodesWithIncoming.has(id));
        
        // If no clear entry point, just use first node
        if (!startNodeId) {
            startNodeId = Object.keys(nodes)[0];
        }
        
        // Layout parameters
        const canvasWidth = $('#workflow-canvas').width();
        const centerX = canvasWidth / 2;
        const verticalSpacing = 150;
        const horizontalSpacing = 250;
        const visited = new Set();
        let maxY = 100;
        
        // Helper function to get node connections
        function getNodeConnections(nodeId) {
            const node = nodes[nodeId];
            const outgoing = connections.filter(c => c.from === nodeId);
            const result = {
                next: null,
                branches: {}
            };
            
            if (node.type === 'condition') {
                outgoing.forEach(conn => {
                    const branch = conn.branch || 'true';
                    result.branches[branch] = conn.to;
                });
            } else if (node.type === 'parallel') {
                result.branches = outgoing.reduce((acc, conn, idx) => {
                    acc[`branch${idx}`] = conn.to;
                    return acc;
                }, {});
            } else if (outgoing.length > 0) {
                result.next = outgoing[0].to;
            }
            
            return result;
        }
        
        // Recursive layout function
        function layoutNode(nodeId, x, y) {
            if (visited.has(nodeId)) return y;
            visited.add(nodeId);
            
            const node = nodes[nodeId];
            if (!node) return y;
            
            // Center node based on type
            let adjustedX = x;
            if (node.type === 'condition' || node.type === 'parallel') {
                adjustedX = x - 70; // Half of diamond width
            } else {
                adjustedX = x - 90; // Half of normal node width
            }
            
            // Position node
            node.x = adjustedX;
            node.y = y;
            $('#' + node.id).css({
                left: node.x + 'px',
                top: node.y + 'px'
            });
            
            maxY = Math.max(maxY, y);
            
            // Get connections
            const conns = getNodeConnections(nodeId);
            let nextY = y + verticalSpacing;
            
            if (node.type === 'condition' && Object.keys(conns.branches).length > 0) {
                // Layout branches side by side at the same Y position
                const leftX = x - horizontalSpacing / 2;
                const rightX = x + horizontalSpacing / 2;
                const branchY = nextY + 50; // Add 50px offset for better visual clarity
                let branchMaxY = branchY;
                
                if (conns.branches.true) {
                    branchMaxY = Math.max(branchMaxY, layoutNode(conns.branches.true, leftX, branchY));
                }
                if (conns.branches.false) {
                    branchMaxY = Math.max(branchMaxY, layoutNode(conns.branches.false, rightX, branchY));
                }
                nextY = branchMaxY;
            } else if (node.type === 'parallel' && Object.keys(conns.branches).length > 0) {
                // Layout parallel branches at the same Y position
                const branchCount = Object.keys(conns.branches).length;
                // Reduce spacing if too many branches
                const adjustedSpacing = branchCount > 4 ? horizontalSpacing * 0.7 : horizontalSpacing;
                const totalWidth = (branchCount - 1) * adjustedSpacing;
                let branchX = x - totalWidth / 2;
                const branchY = nextY + 50; // Add 50px offset for better visual clarity
                let branchMaxY = branchY;
                
                Object.values(conns.branches).forEach(targetId => {
                    branchMaxY = Math.max(branchMaxY, layoutNode(targetId, branchX, branchY));
                    branchX += adjustedSpacing;
                });
                nextY = branchMaxY;
            } else if (conns.next) {
                // Regular next node
                nextY = layoutNode(conns.next, x, nextY);
            }
            
            return nextY;
        }
        
        // Start layout from entry point
        layoutNode(startNodeId, centerX, 100);
        
        // Layout any unvisited nodes (disconnected components)
        Object.keys(nodes).forEach(nodeId => {
            if (!visited.has(nodeId)) {
                maxY += verticalSpacing;
                layoutNode(nodeId, centerX, maxY);
            }
        });
        
        updateConnections();
        toastr.success('Uzly byly automaticky rozm√≠stƒõny');
    }
    
    // Load workflow from orchestrator format
    function loadFromOrchestratorFormat(data) {
        if (!data || !data.steps) return;
        
        // Load I/O configuration if available
        if (data.input) {
            workflowIOConfig.input = data.input;
            $('#workflowInputType').val(data.input.type);
        }
        if (data.output) {
            workflowIOConfig.output = data.output;
            $('#workflowOutputType').val(data.output.type);
        }
        
        // Clear existing
        Object.keys(nodes).forEach(nodeId => {
            removeNode(nodeId);
        });
        connections = [];
        
        // Get node positions from metadata if available
        const positions = data.metadata?.nodePositions || {};
        
        // Create nodes from steps
        data.steps.forEach((step, index) => {
            const pos = positions[step.id] || {
                x: 1000,
                y: 300 + (index * 150)
            };
            
            // Map step type back to node type
            let nodeType = 'task';
            if (step.type === 'decision') nodeType = 'condition';
            else if (step.type === 'parallel-gateway') nodeType = 'parallel';
            else if (step.type === 'ai-tool') nodeType = 'ai-tool';
            
            // Create the node
            const nodeId = step.id;
            nodes[nodeId] = {
                id: nodeId,
                type: nodeType,
                name: step.name,
                x: pos.x,
                y: pos.y,
                tools: step.tools || [],
                description: step.description || '',
                condition: step.condition,
                useReAct: step.useReAct,
                orchestrator: step.orchestrator,
                systemPrompt: step.systemPrompt,
                model: step.model,
                temperature: step.temperature
            };
            renderNode(nodes[nodeId]);
        });
        
        // Recreate connections
        
        // Connect steps based on their next/branches
        data.steps.forEach(step => {
            if (step.type === 'decision' && step.branches) {
                // Decision node connections
                if (step.branches.true && step.branches.true.length > 0) {
                    connections.push({
                        from: step.id,
                        to: step.branches.true[0],
                        branch: 'true'
                    });
                }
                if (step.branches.false && step.branches.false.length > 0) {
                    connections.push({
                        from: step.id,
                        to: step.branches.false[0],
                        branch: 'false'
                    });
                }
            } else if (step.type === 'parallel-gateway' && step.branches) {
                // Parallel gateway connections
                step.branches.forEach(targetId => {
                    connections.push({
                        from: step.id,
                        to: targetId
                    });
                });
            } else if (step.next) {
                // Regular step connection
                connections.push({
                    from: step.id,
                    to: step.next
                });
            }
            // Final steps just don't have outgoing connections
        });
        
        updateConnections();
        toastr.info('Workflow naƒçteno');
    }
    
    // Load workflow from server
    function loadWorkflowFromServer() {
        $.ajax({
            url: '/WorkflowDesigner/LoadWorkflow',
            type: 'GET',
            data: { projectId: currentProjectId },
            success: function(response) {
                if (response.success && response.orchestratorData) {
                    // Load saved workflow
                    loadFromOrchestratorFormat(response.orchestratorData);
                    console.log('Loaded nodes:', nodes);
                    console.log('Loaded connections:', connections);
                } else {
                    // Create new workflow with start/end
                    loadInitialWorkflow();
                }
            },
            error: function() {
                // Create new workflow on error
                loadInitialWorkflow();
            }
        });
    }
    
    // Zoom functions
    function zoomIn() {
        currentZoom = Math.min(currentZoom + 0.1, 2.0);
        applyZoom();
    }
    
    function zoomOut() {
        currentZoom = Math.max(currentZoom - 0.1, 0.5);
        applyZoom();
    }
    
    function zoomReset() {
        currentZoom = 1.0;
        applyZoom();
    }
    
    function applyZoom() {
        $('#workflow-canvas').css('transform', `scale(${currentZoom})`);
        $('#workflow-canvas').css('transform-origin', '0 0');
        
        // Also scale the SVG overlay
        $('#connections-svg').css('transform', `scale(${currentZoom})`);
        $('#connections-svg').css('transform-origin', '0 0');
        
        // Update zoom display
        $('.zoom-level').text(Math.round(currentZoom * 100) + '%');
        
        // Adjust canvas size to prevent cutoff
        $('.canvas-container').css('overflow', 'auto');
    }
    
    // Toggle advanced settings in node edit modal
    function toggleAdvancedSettings() {
        $('#advancedSettingsContent').slideToggle();
    }
</script>
}