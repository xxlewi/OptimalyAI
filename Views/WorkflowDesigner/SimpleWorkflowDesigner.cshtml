@model OptimalyAI.ViewModels.WorkflowGraphViewModel
@{
    ViewData["Title"] = "Workflow Designer";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<style>
    .designer-container {
        display: flex;
        height: calc(100vh - 200px);
        gap: 20px;
    }
    
    .toolbox {
        width: 250px;
        background: #f8f9fa;
        border-radius: 8px;
        padding: 20px;
        overflow-y: auto;
    }
    
    .toolbox h6 {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
    }
    
    .tool-item {
        background: white;
        border: 2px solid #ddd;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 10px;
        cursor: move;
        text-align: center;
        transition: all 0.2s;
    }
    
    .tool-item:hover {
        border-color: #007bff;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .canvas-container {
        flex: 1;
        background: white;
        border: 2px solid #ddd;
        border-radius: 8px;
        position: relative;
        overflow: auto;
    }
    
    #workflow-canvas {
        width: 2000px;
        height: 1500px;
        position: relative;
        background-image: 
            linear-gradient(rgba(0,0,0,.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0,0,0,.05) 1px, transparent 1px);
        background-size: 20px 20px;
    }
    
    .workflow-node {
        position: absolute;
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        padding: 15px;
        min-width: 180px;
        cursor: move;
        user-select: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .workflow-node.selected {
        border-color: #ff6b6b;
        box-shadow: 0 0 0 3px rgba(255,107,107,0.2);
    }
    
    .workflow-node.start {
        background: #28a745;
        color: white;
        border-color: #28a745;
        border-radius: 50px;
        text-align: center;
    }
    
    .workflow-node.end {
        background: #dc3545;
        color: white;
        border-color: #dc3545;
        border-radius: 50px;
        text-align: center;
    }
    
    .workflow-node.condition {
        width: 140px;
        height: 140px;
        border: none !important;
        background: transparent !important;
        padding: 0;
        min-width: unset;
        box-shadow: none !important;
    }
    
    .workflow-node.condition::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: rotate(45deg);
        border: 3px solid #ffc107;
        background: #fff8e1;
        border-radius: 15px;
        z-index: 1;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .workflow-node.condition .node-content-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 2;
    }
    
    .workflow-node.condition .node-header {
        margin-bottom: 5px;
        text-align: center;
        font-size: 14px;
        position: relative;
    }
    
    .workflow-node.condition .node-close {
        position: absolute;
        top: 23px;
        right: -40px;
        z-index: 3;
        background: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 1;
    }
    
    /* Position dots at diamond vertices */
    .workflow-node.condition .connection-dot.input {
        top: -27px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .workflow-node.condition .connection-dot.output {
        bottom: -8px;
        transform: translateX(-50%);
        top: auto;
    }
    
    .workflow-node.condition .connection-dot.output.true {
        left: 15%;
        bottom: 15%;
        background: #28a745;
        transform: translate(-50%, 50%);
    }
    
    .workflow-node.condition .connection-dot.output.false {
        right: 15%;
        bottom: 15%;
        left: auto;
        background: #dc3545;
        transform: translate(50%, 50%);
    }
    
    .workflow-node.parallel {
        width: 140px;
        height: 140px;
        border: none !important;
        background: transparent !important;
        padding: 0;
        min-width: unset;
        box-shadow: none !important;
    }
    
    .workflow-node.parallel::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: rotate(45deg);
        border: 3px solid #6f42c1;
        background: #f3e5f5;
        border-radius: 15px;
        z-index: 1;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .workflow-node.parallel::after {
        content: '+';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        font-weight: bold;
        color: #6f42c1;
        z-index: 2;
    }
    
    .workflow-node.parallel .node-content-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
        z-index: 3;
    }
    
    .workflow-node.parallel .node-header {
        font-size: 14px;
        text-align: center;
        position: relative;
    }
    
    .workflow-node.parallel .node-close {
        position: absolute;
        top: 23px;
        right: -40px;
        z-index: 3;
        background: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 1;
    }
    
    /* Position parallel gateway dots on diamond vertices */
    .workflow-node.parallel .connection-dot.input {
        top: -27px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .workflow-node.parallel .connection-dot.output {
        bottom: -27px;
        left: 50%;
        background: #6f42c1;
        transform: translateX(-50%);
    }
    
    .node-header {
        font-weight: bold;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .node-close {
        cursor: pointer;
        color: #999;
        font-size: 18px;
        line-height: 1;
    }
    
    .node-close:hover {
        color: #dc3545;
    }
    
    .node-tools {
        font-size: 12px;
        margin-top: 8px;
    }
    
    .tool-badge {
        display: inline-block;
        background: #e3f2fd;
        color: #1976d2;
        padding: 2px 8px;
        border-radius: 4px;
        margin-right: 4px;
    }
    
    .connection-line {
        stroke: #007bff;
        stroke-width: 3;
        fill: none;
        pointer-events: none;
    }
    
    .connection-dot {
        width: 12px;
        height: 12px;
        background: #007bff;
        border: 2px solid white;
        border-radius: 50%;
        position: absolute;
        cursor: crosshair;
        z-index: 20;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .connection-dot:hover {
        background: #0056b3;
        transform: scale(1.2);
    }
    
    .connection-dot.input {
        left: 50%;
        top: -8px;
        transform: translateX(-50%);
    }
    
    /* Hide connection dots for start node (it has no input) */
    .workflow-node.start .connection-dot.input {
        display: none;
    }
    
    .connection-dot.input:hover {
        transform: translateX(-50%) scale(1.2);
    }
    
    .connection-dot.output {
        left: 50%;
        bottom: -8px;
        transform: translateX(-50%);
    }
    
    /* Hide connection dots for end node (it has no output) */
    .workflow-node.end .connection-dot.output {
        display: none;
    }
    
    .connection-dot.output:hover {
        transform: translateX(-50%) scale(1.2);
    }
    
    .toolbar {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
    }
</style>

<div class="content-header">
    <div class="container-fluid">
        <div class="row mb-2">
            <div class="col-sm-6">
                <h1>
                    <i class="fas fa-project-diagram"></i> Workflow Designer
                    <small class="text-muted">@Model.ProjectName</small>
                </h1>
            </div>
            <div class="col-sm-6">
                <div class="float-sm-right">
                    <button class="btn btn-success" onclick="saveWorkflow()">
                        <i class="fas fa-save"></i> Ulo≈æit
                    </button>
                    <button class="btn btn-info" onclick="validateWorkflow()">
                        <i class="fas fa-check"></i> Validovat
                    </button>
                    <button class="btn btn-primary" onclick="testWorkflow()">
                        <i class="fas fa-play"></i> Test
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<section class="content">
    <div class="container-fluid">
        <div class="toolbar">
            <button class="btn btn-sm btn-secondary" onclick="clearWorkflow()">
                <i class="fas fa-trash"></i> Vyƒçistit
            </button>
            <button class="btn btn-sm btn-secondary" onclick="autoLayout()">
                <i class="fas fa-magic"></i> Automatick√© rozlo≈æen√≠
            </button>
            <span class="ml-auto text-muted">
                P≈ôet√°hnƒõte bloky z panelu n√°stroj≈Ø
            </span>
        </div>
        
        <div class="designer-container">
            <!-- Toolbox -->
            <div class="toolbox">
                <h5><i class="fas fa-toolbox"></i> N√°stroje</h5>
                
                <h6>Z√°kladn√≠ uzly</h6>
                <div class="tool-item" data-type="task" draggable="true">
                    <i class="fas fa-square"></i> Proces
                    <small style="display: block; font-size: 10px; color: #666;">Obd√©ln√≠k</small>
                </div>
                <div class="tool-item" data-type="condition" draggable="true">
                    <i class="fas fa-question-circle"></i> Rozhodnut√≠
                    <small style="display: block; font-size: 10px; color: #666;">Podm√≠nka</small>
                </div>
                <div class="tool-item" data-type="parallel" draggable="true">
                    <i class="fas fa-plus"></i> Paraleln√≠ br√°na
                    <small style="display: block; font-size: 10px; color: #666;">AND Gateway</small>
                </div>
                
                <hr>
                
                <h6>AI N√°stroje</h6>
                @foreach(var tool in ViewBag.AvailableTools ?? new List<string>())
                {
                    <div class="tool-item" data-type="ai-tool" data-tool="@tool" draggable="true">
                        <i class="fas fa-robot"></i> @tool.Replace("_", " ")
                    </div>
                }
            </div>
            
            <!-- Canvas -->
            <div class="canvas-container">
                <div id="workflow-canvas">
                    <svg id="connections-svg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; z-index: 100;">
                        <defs>
                            <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#007bff" />
                            </marker>
                            <marker id="arrowhead-green" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#28a745" />
                            </marker>
                            <marker id="arrowhead-red" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#dc3545" />
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Node Edit Modal -->
<div class="modal fade" id="nodeEditModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Upravit uzel</h5>
                <button type="button" class="close" data-dismiss="modal">
                    <span>&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editingNodeId">
                <div class="form-group">
                    <label>N√°zev</label>
                    <input type="text" class="form-control" id="nodeName">
                </div>
                <div class="form-group">
                    <label>Popis</label>
                    <textarea class="form-control" id="nodeDescription" rows="3"></textarea>
                </div>
                <div class="form-group" id="toolsSection">
                    <label>AI N√°stroje</label>
                    <select multiple class="form-control" id="nodeTools" size="5">
                        @foreach(var tool in ViewBag.AvailableTools ?? new List<string>())
                        {
                            <option value="@tool">@tool.Replace("_", " ")</option>
                        }
                    </select>
                    <small class="text-muted">Dr≈æte Ctrl pro v√Ωbƒõr v√≠ce n√°stroj≈Ø</small>
                </div>
                <div class="form-group" id="conditionSection" style="display: none;">
                    <label>Podm√≠nka</label>
                    <input type="text" class="form-control" id="nodeCondition" placeholder="result > 0">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger" onclick="deleteCurrentNode()">
                    <i class="fas fa-trash"></i> Smazat
                </button>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Zru≈°it</button>
                <button type="button" class="btn btn-primary" onclick="updateCurrentNode()">
                    <i class="fas fa-save"></i> Ulo≈æit
                </button>
            </div>
        </div>
    </div>
</div>

@section Scripts {
<script>
    // Workflow state
    let nodes = {};
    let connections = [];
    let selectedNode = null;
    let nodeIdCounter = 1;
    let draggedElement = null;
    let isConnecting = false;
    let connectionStart = null;
    const currentProjectId = '@Model.ProjectId';
    
    // Initialize
    $(document).ready(function() {
        initializeDragAndDrop();
        initializeCanvas();
        initializeKeyboardShortcuts();
        loadInitialWorkflow();
    });
    
    // Initialize drag and drop
    function initializeDragAndDrop() {
        // Toolbox items
        $('.tool-item').on('dragstart', function(e) {
            e.originalEvent.dataTransfer.setData('type', $(this).data('type'));
            e.originalEvent.dataTransfer.setData('tool', $(this).data('tool') || '');
        });
        
        // Canvas
        $('#workflow-canvas').on('dragover', function(e) {
            e.preventDefault();
        }).on('drop', function(e) {
            e.preventDefault();
            const type = e.originalEvent.dataTransfer.getData('type');
            const tool = e.originalEvent.dataTransfer.getData('tool');
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            createNode(type, x, y, tool);
        });
    }
    
    // Initialize canvas events
    function initializeCanvas() {
        $('#workflow-canvas').on('click', function(e) {
            if (e.target === this) {
                deselectAll();
            }
        });
    }
    
    // Initialize keyboard shortcuts
    function initializeKeyboardShortcuts() {
        $(document).on('keydown', function(e) {
            // Delete or Backspace key
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Prevent backspace from navigating back if not in an input field
                if (!$(e.target).is('input, textarea')) {
                    e.preventDefault();
                    
                    // Delete selected node if any
                    if (selectedNode) {
                        const node = nodes[selectedNode];
                        // Don't delete start/end nodes
                        if (node && node.type !== 'start' && node.type !== 'end') {
                            removeNode(selectedNode);
                        }
                    }
                }
            }
        });
    }
    
    // Create new node
    function createNode(type, x, y, tool) {
        const nodeId = 'node_' + nodeIdCounter++;
        
        // Default descriptions - none for start/end
        const defaultDescriptions = {
            'start': '',
            'end': '',
            'task': 'Zpracov√°n√≠ dat nebo operace',
            'condition': 'Rozhodovac√≠ bod (if/else)',
            'parallel': 'Paraleln√≠ zpracov√°n√≠',
            'ai-tool': 'Vol√°n√≠ AI n√°stroje'
        };
        
        // For vertical layout, center nodes horizontally
        const centerX = $('#workflow-canvas').width() / 2 - 100; // 100 is half of min-width
        
        // Adjust position for diamond shapes (condition and parallel)
        let adjustedX = x - 90;
        let adjustedY = y - 30;
        if (type === 'condition' || type === 'parallel') {
            adjustedX = x - 70; // Half of diamond width
            adjustedY = y - 70; // Half of diamond height
        }
        
        const node = {
            id: nodeId,
            type: type,
            name: tool ? tool.replace(/_/g, ' ') : getNodeTypeName(type),
            x: adjustedX,
            y: adjustedY,
            tools: tool ? [tool] : [],
            description: defaultDescriptions[type] || ''
        };
        
        nodes[nodeId] = node;
        renderNode(node);
    }
    
    // Get node type display name
    function getNodeTypeName(type) {
        const names = {
            'start': 'Zaƒç√°tek',
            'end': 'Konec',
            'task': 'Proces',
            'condition': 'Rozhodnut√≠',
            'parallel': 'Paraleln√≠ br√°na'
        };
        return names[type] || type;
    }
    
    // Render node
    function renderNode(node) {
        const nodeEl = $('<div>')
            .addClass('workflow-node')
            .addClass(node.type)
            .attr('id', node.id)
            .css({
                left: node.x + 'px',
                top: node.y + 'px'
            });
        
        // Create wrapper for diamond-shaped nodes (condition and parallel)
        let contentWrapper;
        if (node.type === 'condition' || node.type === 'parallel') {
            contentWrapper = $('<div>').addClass('node-content-wrapper');
            nodeEl.append(contentWrapper);
        } else {
            contentWrapper = nodeEl;
        }
        
        // Header
        const header = $('<div>').addClass('node-header');
        header.append($('<span>').html(`<i class="${getNodeIcon(node.type)}"></i> ${node.name}`));
        
        // Close button (not for start/end)
        if (node.type !== 'start' && node.type !== 'end') {
            header.append($('<span>').addClass('node-close').html('√ó').click(function(e) {
                e.stopPropagation();
                removeNode(node.id);
            }));
        }
        
        contentWrapper.append(header);
        
        // Description - but not for start/end nodes
        if (node.description && node.type !== 'start' && node.type !== 'end') {
            const descDiv = $('<div>')
                .css({
                    fontSize: '12px',
                    color: '#666',
                    marginTop: '5px',
                    fontStyle: 'italic'
                })
                .text(node.description);
            contentWrapper.append(descDiv);
        }
        
        // Tools
        if (node.tools && node.tools.length > 0) {
            const toolsDiv = $('<div>').addClass('node-tools');
            node.tools.forEach(tool => {
                toolsDiv.append($('<span>').addClass('tool-badge').text(tool.replace(/_/g, ' ')));
            });
            contentWrapper.append(toolsDiv);
        }
        
        // Connection dots
        if (node.type !== 'start') {
            nodeEl.append($('<div>').addClass('connection-dot input'));
        }
        if (node.type !== 'end') {
            if (node.type === 'condition') {
                // Two outputs for condition - TRUE and FALSE
                nodeEl.append($('<div>')
                    .addClass('connection-dot output true')
                    .attr('title', 'TRUE')
                    .attr('data-branch', 'true'));
                nodeEl.append($('<div>')
                    .addClass('connection-dot output false')
                    .attr('title', 'FALSE')
                    .attr('data-branch', 'false'));
            } else {
                nodeEl.append($('<div>').addClass('connection-dot output'));
            }
        }
        
        // Events
        nodeEl.on('click', function(e) {
            e.stopPropagation();
            selectNode(node.id);
        });
        
        nodeEl.on('dblclick', function(e) {
            e.stopPropagation();
            editNode(node.id);
        });
        
        // Make draggable
        makeDraggable(nodeEl, node);
        
        // Connection events - mus√≠me pou≈æ√≠t delegated events
        nodeEl.on('mousedown', '.connection-dot.output', function(e) {
            e.stopPropagation();
            e.preventDefault();
            const branch = $(this).attr('data-branch');
            startConnection(node.id, branch);
            return false;
        });
        
        nodeEl.on('mouseup', '.connection-dot.input', function(e) {
            e.stopPropagation();
            e.preventDefault();
            if (isConnecting && connectionStart !== node.id) {
                endConnection(node.id);
            }
            return false;
        });
        
        $('#workflow-canvas').append(nodeEl);
    }
    
    // Get node icon
    function getNodeIcon(type) {
        const icons = {
            'start': 'fas fa-play-circle',
            'end': 'fas fa-stop-circle',
            'task': 'fas fa-tasks',
            'condition': 'fas fa-question-circle',
            'parallel': 'fas fa-code-branch',
            'ai-tool': 'fas fa-robot'
        };
        return icons[type] || 'fas fa-circle';
    }
    
    // Make element draggable
    function makeDraggable(element, node) {
        let isDragging = false;
        let startX, startY, initialX, initialY;
        
        element.on('mousedown', function(e) {
            if ($(e.target).hasClass('node-close') || $(e.target).hasClass('connection-dot')) return;
            
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            initialX = node.x;
            initialY = node.y;
            
            $(document).on('mousemove.drag', function(e) {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                node.x = initialX + dx;
                node.y = initialY + dy;
                
                element.css({
                    left: node.x + 'px',
                    top: node.y + 'px'
                });
                
                updateConnections();
            });
            
            $(document).on('mouseup.drag', function() {
                isDragging = false;
                $(document).off('.drag');
            });
        });
    }
    
    // Connection management
    function startConnection(nodeId, branch) {
        console.log('Starting connection from:', nodeId, 'branch:', branch);
        isConnecting = true;
        connectionStart = {
            nodeId: nodeId,
            branch: branch
        };
        
        // Change cursor
        $('#workflow-canvas').css('cursor', 'crosshair');
        
        // Create temporary line
        const tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tempLine.setAttribute('id', 'temp-connection');
        tempLine.setAttribute('class', 'connection-line');
        tempLine.setAttribute('stroke', '#ff6b6b');
        tempLine.setAttribute('stroke-dasharray', '5,5');
        $('#connections-svg')[0].appendChild(tempLine);
        
        // Get start position - from output dot
        const startNode = nodes[nodeId];
        const startEl = $('#' + nodeId);
        
        // Find the specific output dot we're dragging from
        let outputDot;
        if (branch) {
            outputDot = startEl.find(`.connection-dot.output.${branch}`);
        } else {
            outputDot = startEl.find('.connection-dot.output');
        }
        
        // Get exact position of the connection dot
        const dotPos = outputDot.position();
        const nodePos = startEl.position();
        const startX = nodePos.left + dotPos.left + 6; // 6 is half of dot width
        const startY = nodePos.top + dotPos.top + 6;
        
        // Mouse move to update temp line
        $(document).on('mousemove.connection', function(e) {
            const rect = $('#workflow-canvas')[0].getBoundingClientRect();
            const x = e.clientX - rect.left + $('#workflow-canvas').scrollLeft();
            const y = e.clientY - rect.top + $('#workflow-canvas').scrollTop();
            
            tempLine.setAttribute('x1', startX);
            tempLine.setAttribute('y1', startY);
            tempLine.setAttribute('x2', x);
            tempLine.setAttribute('y2', y);
        });
        
        // Global mouseup to cancel connection
        $(document).on('mouseup.connection', function(e) {
            // If not on a valid input, cancel
            if (!$(e.target).hasClass('connection-dot') || !$(e.target).hasClass('input')) {
                console.log('Connection cancelled');
                
                // Clean up
                $('#temp-connection').remove();
                isConnecting = false;
                connectionStart = null;
                $('#workflow-canvas').css('cursor', 'default');
                $(document).off('.connection');
            }
        });
    }
    
    function endConnection(nodeId) {
        console.log('Ending connection at:', nodeId);
        if (connectionStart && connectionStart.nodeId !== nodeId) {
            // Check if connection already exists
            const exists = connections.some(c => 
                c.from === connectionStart.nodeId && c.to === nodeId
            );
            
            if (!exists) {
                // Check if output already has a connection (except for parallel gateway)
                const fromNode = nodes[connectionStart.nodeId];
                const existingFromOutput = connections.filter(c => 
                    c.from === connectionStart.nodeId && 
                    (!connectionStart.branch || c.branch === connectionStart.branch)
                );
                
                // Allow only one connection per output, except for parallel gateway
                if (existingFromOutput.length > 0 && fromNode.type !== 'parallel') {
                    toastr.warning('Tento v√Ωstup u≈æ m√° spojen√≠. Nejd≈ô√≠v ho odstra≈àte.');
                    cancelConnection();
                    return;
                }
                
                const connection = {
                    from: connectionStart.nodeId,
                    to: nodeId
                };
                
                // If from a condition node, store which branch
                if (connectionStart.branch) {
                    connection.branch = connectionStart.branch;
                }
                
                connections.push(connection);
                updateConnections();
                
                const branchInfo = connectionStart.branch ? ` (${connectionStart.branch.toUpperCase()})` : '';
                toastr.success('Propojeno' + branchInfo + '!');
            } else {
                toastr.warning('Toto propojen√≠ ji≈æ existuje');
            }
        }
        
        // Clean up
        $('#temp-connection').remove();
        isConnecting = false;
        connectionStart = null;
        $('#workflow-canvas').css('cursor', 'default');
        $(document).off('.connection');
    }
    
    function cancelConnection() {
        // Clean up
        $('#temp-connection').remove();
        isConnecting = false;
        connectionStart = null;
        $('#workflow-canvas').css('cursor', 'default');
        $(document).off('.connection');
    }
    
    // Update SVG connections
    function updateConnections() {
        const svg = $('#connections-svg');
        svg.find('line:not(#temp-connection)').remove();
        
        connections.forEach(conn => {
            const fromNode = nodes[conn.from];
            const toNode = nodes[conn.to];
            
            if (fromNode && toNode) {
                const fromEl = $('#' + conn.from);
                const toEl = $('#' + conn.to);
                
                // Get exact positions from connection dots
                let outputDot;
                if (conn.branch && fromNode.type === 'condition') {
                    outputDot = fromEl.find(`.connection-dot.output.${conn.branch}`);
                } else {
                    outputDot = fromEl.find('.connection-dot.output');
                }
                
                const inputDot = toEl.find('.connection-dot.input');
                
                // Calculate exact positions
                const fromNodePos = fromEl.position();
                const outputDotPos = outputDot.position();
                const x1 = fromNodePos.left + outputDotPos.left + 6;
                const y1 = fromNodePos.top + outputDotPos.top + 6;
                
                const toNodePos = toEl.position();
                const inputDotPos = inputDot.position();
                const x2 = toNodePos.left + inputDotPos.left + 6;
                const y2 = toNodePos.top + inputDotPos.top + 6;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('class', 'connection-line');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                
                // Color code branches and use appropriate arrowhead
                if (conn.branch === 'true') {
                    line.setAttribute('stroke', '#28a745');
                    line.setAttribute('marker-end', 'url(#arrowhead-green)');
                } else if (conn.branch === 'false') {
                    line.setAttribute('stroke', '#dc3545');
                    line.setAttribute('marker-end', 'url(#arrowhead-red)');
                }
                
                svg[0].appendChild(line);
            }
        });
    }
    
    // Node selection
    function selectNode(nodeId) {
        deselectAll();
        selectedNode = nodeId;
        $('#' + nodeId).addClass('selected');
    }
    
    function deselectAll() {
        selectedNode = null;
        $('.workflow-node').removeClass('selected');
    }
    
    // Edit node
    function editNode(nodeId) {
        const node = nodes[nodeId];
        if (!node) return;
        
        $('#editingNodeId').val(nodeId);
        $('#nodeName').val(node.name);
        $('#nodeDescription').val(node.description || '');
        
        // Show/hide sections based on type
        if (node.type === 'condition') {
            $('#toolsSection').hide();
            $('#conditionSection').show();
            $('#nodeCondition').val(node.condition || '');
        } else {
            $('#toolsSection').show();
            $('#conditionSection').hide();
            
            // Set selected tools
            $('#nodeTools').val(node.tools || []);
        }
        
        $('#nodeEditModal').modal('show');
    }
    
    // Update node
    function updateCurrentNode() {
        const nodeId = $('#editingNodeId').val();
        const node = nodes[nodeId];
        if (!node) return;
        
        node.name = $('#nodeName').val();
        node.description = $('#nodeDescription').val();
        
        if (node.type === 'condition') {
            node.condition = $('#nodeCondition').val();
        } else {
            node.tools = $('#nodeTools').val() || [];
        }
        
        // Re-render node
        $('#' + nodeId).remove();
        renderNode(node);
        
        $('#nodeEditModal').modal('hide');
    }
    
    // Delete node
    function deleteCurrentNode() {
        const nodeId = $('#editingNodeId').val();
        removeNode(nodeId);
        $('#nodeEditModal').modal('hide');
    }
    
    function removeNode(nodeId) {
        delete nodes[nodeId];
        $('#' + nodeId).remove();
        
        // Remove connections
        connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);
        updateConnections();
    }
    
    // Load initial workflow
    function loadInitialWorkflow() {
        // Center in visible viewport
        const viewportWidth = $('.canvas-container').width();
        const viewportHeight = $('.canvas-container').height();
        const centerX = viewportWidth / 2;
        
        // Create start and end nodes - at top and bottom of viewport
        createNode('start', centerX, 30);  // At the very top with small margin
        createNode('end', centerX, viewportHeight - 50);  // At the very bottom with small margin
        
        // Load existing nodes from model if any
        const model = @Html.Raw(Json.Serialize(Model));
        if (model && model.nodes && model.nodes.length > 2) {
            // Load additional nodes from model
            // This is simplified - you'd map the model structure
        }
    }
    
    // Workflow operations
    function saveWorkflow() {
        // Convert to orchestrator-compatible format
        const workflowData = convertToOrchestratorFormat();
        
        console.log('Saving workflow:', workflowData);
        
        // Send to server
        $.ajax({
            url: '/WorkflowDesigner/SaveWorkflow',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                ProjectId: '@Model.ProjectId',
                WorkflowData: workflowData
            }),
            success: function(response) {
                if (response.success) {
                    toastr.success('Workflow ulo≈æeno');
                } else {
                    toastr.error('Chyba p≈ôi ukl√°d√°n√≠');
                }
            },
            error: function() {
                toastr.error('Chyba p≈ôi komunikaci se serverem');
            }
        });
    }
    
    // Convert visual workflow to orchestrator format
    function convertToOrchestratorFormat() {
        const steps = [];
        const nodeMap = {};
        
        // First pass - create steps
        Object.values(nodes).forEach((node, index) => {
            if (node.type === 'start' || node.type === 'end') {
                return; // Skip start/end nodes
            }
            
            const step = {
                id: node.id,
                name: node.name,
                type: mapNodeTypeToStepType(node.type),
                description: node.description || '',
                position: index
            };
            
            // Add type-specific properties
            if (node.type === 'task' || node.type === 'ai-tool') {
                step.tools = node.tools || [];
                step.useReAct = node.useReAct || false;
            } else if (node.type === 'condition') {
                step.condition = node.condition || 'true';
                step.branches = {
                    true: [],
                    false: []
                };
            } else if (node.type === 'parallel') {
                step.branches = [];
            }
            
            steps.push(step);
            nodeMap[node.id] = step;
        });
        
        // Second pass - build connections
        const startNode = Object.values(nodes).find(n => n.type === 'start');
        const endNode = Object.values(nodes).find(n => n.type === 'end');
        
        // Find first step after start
        const firstConnection = connections.find(c => c.from === startNode?.id);
        const firstStepId = firstConnection ? firstConnection.to : null;
        
        // Find all connections to end node
        const endConnections = connections.filter(c => c.to === endNode?.id);
        const lastStepIds = endConnections.map(c => c.from);
        
        // Build step sequence
        steps.forEach(step => {
            const outgoingConnections = connections.filter(c => c.from === step.id);
            
            if (step.type === 'condition') {
                // For conditions, we need to determine true/false branches
                outgoingConnections.forEach((conn, index) => {
                    const targetStep = nodeMap[conn.to];
                    if (targetStep) {
                        // Simple logic: first connection is true, second is false
                        const branch = index === 0 ? 'true' : 'false';
                        step.branches[branch].push(targetStep.id);
                    }
                });
            } else if (step.type === 'parallel') {
                // For parallel, all connections are branches
                step.branches = outgoingConnections
                    .map(conn => nodeMap[conn.to]?.id)
                    .filter(id => id != null);
            } else {
                // For regular steps, find next step
                const nextConnection = outgoingConnections[0];
                if (nextConnection) {
                    // Check if next is END node
                    if (nextConnection.to === endNode?.id) {
                        step.next = null; // This is a final step
                        step.isFinal = true;
                    } else {
                        const nextStep = nodeMap[nextConnection.to];
                        if (nextStep) {
                            step.next = nextStep.id;
                        }
                    }
                }
            }
        });
        
        return {
            name: 'Workflow ' + new Date().toISOString(),
            description: 'Visual workflow designer output',
            startNodeId: startNode?.id,
            endNodeId: endNode?.id,
            firstStepId: firstStepId,
            lastStepIds: lastStepIds,
            steps: steps,
            metadata: {
                createdWith: 'SimpleWorkflowDesigner',
                createdAt: new Date().toISOString(),
                hasValidStart: !!startNode,
                hasValidEnd: !!endNode,
                nodePositions: Object.values(nodes).reduce((acc, node) => {
                    acc[node.id] = { 
                        x: node.x, 
                        y: node.y,
                        type: node.type
                    };
                    return acc;
                }, {})
            }
        };
    }
    
    function mapNodeTypeToStepType(nodeType) {
        const typeMap = {
            'task': 'process',
            'ai-tool': 'ai-tool',
            'condition': 'decision',
            'parallel': 'parallel-gateway'
        };
        return typeMap[nodeType] || nodeType;
    }
    
    function validateWorkflow() {
        const errors = [];
        
        // Check for start node
        const hasStart = Object.values(nodes).some(n => n.type === 'start');
        if (!hasStart) errors.push('Chyb√≠ poƒç√°teƒçn√≠ uzel');
        
        // Check for end node  
        const hasEnd = Object.values(nodes).some(n => n.type === 'end');
        if (!hasEnd) errors.push('Chyb√≠ koncov√Ω uzel');
        
        // Check disconnected nodes
        Object.values(nodes).forEach(node => {
            if (node.type !== 'start' && node.type !== 'end') {
                const hasInput = connections.some(c => c.to === node.id);
                const hasOutput = connections.some(c => c.from === node.id);
                
                if (!hasInput) errors.push(`Uzel "${node.name}" nem√° vstup`);
                if (!hasOutput) errors.push(`Uzel "${node.name}" nem√° v√Ωstup`);
            }
        });
        
        if (errors.length === 0) {
            toastr.success('Workflow je validn√≠');
        } else {
            toastr.error(errors.join('<br>'), 'Chyby ve workflow');
        }
    }
    
    function testWorkflow() {
        const workflowData = convertToOrchestratorFormat();
        
        // Show JSON in console for debugging
        console.log('Orchestrator format:', JSON.stringify(workflowData, null, 2));
        
        // You can also show it in a modal or download as file
        const jsonStr = JSON.stringify(workflowData, null, 2);
        
        // Create download link
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `workflow-${currentProjectId || 'export'}-orchestrator.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        toastr.info('Export pro orchestr√°tor byl sta≈æen');
    }
    
    function clearWorkflow() {
        if (confirm('Opravdu vymazat workflow?')) {
            nodes = {};
            connections = [];
            $('.workflow-node').remove();
            $('svg line').remove();
            
            // Add back start and end
            loadInitialWorkflow();
        }
    }
    
    function autoLayout() {
        // Find start node
        const startNode = Object.values(nodes).find(n => n.type === 'start');
        if (!startNode) {
            toastr.error('Chyb√≠ poƒç√°teƒçn√≠ uzel');
            return;
        }
        
        // Build ordered list based on connections
        const orderedNodes = [];
        const visited = new Set();
        const queue = [startNode.id];
        
        while (queue.length > 0) {
            const currentId = queue.shift();
            if (visited.has(currentId)) continue;
            
            visited.add(currentId);
            const currentNode = nodes[currentId];
            if (currentNode) {
                orderedNodes.push(currentNode);
                
                // Find all connections from this node
                const outgoing = connections.filter(c => c.from === currentId);
                outgoing.forEach(conn => {
                    if (!visited.has(conn.to)) {
                        queue.push(conn.to);
                    }
                });
            }
        }
        
        // Position nodes vertically in order - center in viewport
        const viewportWidth = $('.canvas-container').width();
        const scrollLeft = $('.canvas-container').scrollLeft();
        const centerX = scrollLeft + (viewportWidth / 2) - 100;
        let y = 100;
        const spacing = 150;
        
        orderedNodes.forEach(node => {
            // Center all nodes except diamonds which need offset
            let x = centerX;
            if (node.type === 'condition' || node.type === 'parallel') {
                x = centerX + 30; // Offset for diamond shape centering
            }
            
            node.x = x;
            node.y = y;
            $('#' + node.id).css({
                left: node.x + 'px',
                top: node.y + 'px'
            });
            y += spacing;
        });
        
        updateConnections();
        toastr.success('Uzly byly automaticky rozm√≠stƒõny');
    }
</script>
}